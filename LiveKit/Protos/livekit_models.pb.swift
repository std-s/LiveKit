// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: livekit_models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Livekit_TrackType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case audio // = 0
  case video // = 1
  case data // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .audio
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .audio
    case 1: self = .video
    case 2: self = .data
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .audio: return 0
    case .video: return 1
    case .data: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Livekit_TrackType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_TrackType] = [
    .audio,
    .video,
    .data,
  ]
}

#endif  // swift(>=4.2)

enum Livekit_TrackSource: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case camera // = 1
  case microphone // = 2
  case screenShare // = 3
  case screenShareAudio // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .camera
    case 2: self = .microphone
    case 3: self = .screenShare
    case 4: self = .screenShareAudio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .camera: return 1
    case .microphone: return 2
    case .screenShare: return 3
    case .screenShareAudio: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Livekit_TrackSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_TrackSource] = [
    .unknown,
    .camera,
    .microphone,
    .screenShare,
    .screenShareAudio,
  ]
}

#endif  // swift(>=4.2)

enum Livekit_VideoQuality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case low // = 0
  case medium // = 1
  case high // = 2
  case off // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .low
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .low
    case 1: self = .medium
    case 2: self = .high
    case 3: self = .off
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .low: return 0
    case .medium: return 1
    case .high: return 2
    case .off: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Livekit_VideoQuality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_VideoQuality] = [
    .low,
    .medium,
    .high,
    .off,
  ]
}

#endif  // swift(>=4.2)

enum Livekit_ConnectionQuality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case poor // = 0
  case good // = 1
  case excellent // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .poor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .poor
    case 1: self = .good
    case 2: self = .excellent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .poor: return 0
    case .good: return 1
    case .excellent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Livekit_ConnectionQuality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_ConnectionQuality] = [
    .poor,
    .good,
    .excellent,
  ]
}

#endif  // swift(>=4.2)

enum Livekit_ClientConfigSetting: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unset // = 0
  case disabled // = 1
  case enabled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .disabled
    case 2: self = .enabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .disabled: return 1
    case .enabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Livekit_ClientConfigSetting: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_ClientConfigSetting] = [
    .unset,
    .disabled,
    .enabled,
  ]
}

#endif  // swift(>=4.2)

struct Livekit_Room {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String = String()

  var name: String = String()

  var emptyTimeout: UInt32 = 0

  var maxParticipants: UInt32 = 0

  var creationTime: Int64 = 0

  var turnPassword: String = String()

  var enabledCodecs: [Livekit_Codec] = []

  var metadata: String = String()

  var numParticipants: UInt32 = 0

  var activeRecording: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_Codec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mime: String = String()

  var fmtpLine: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ParticipantPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// allow participant to subscribe to other tracks in the room
  var canSubscribe: Bool = false

  /// allow participant to publish new tracks to room
  var canPublish: Bool = false

  /// allow participant to publish data
  var canPublishData: Bool = false

  /// indicates that it's hidden to others
  var hidden: Bool = false

  /// indicates it's a recorder instance
  var recorder: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ParticipantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String = String()

  var identity: String = String()

  var state: Livekit_ParticipantInfo.State = .joining

  var tracks: [Livekit_TrackInfo] = []

  var metadata: String = String()

  /// timestamp when participant joined room, in seconds
  var joinedAt: Int64 = 0

  var name: String = String()

  var version: UInt32 = 0

  var permission: Livekit_ParticipantPermission {
    get {return _permission ?? Livekit_ParticipantPermission()}
    set {_permission = newValue}
  }
  /// Returns true if `permission` has been explicitly set.
  var hasPermission: Bool {return self._permission != nil}
  /// Clears the value of `permission`. Subsequent reads from it will return its default value.
  mutating func clearPermission() {self._permission = nil}

  var region: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// websocket' connected, but not offered yet
    case joining // = 0

    /// server received client offer
    case joined // = 1

    /// ICE connectivity established
    case active // = 2

    /// WS disconnected
    case disconnected // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .joining
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .joining
      case 1: self = .joined
      case 2: self = .active
      case 3: self = .disconnected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .joining: return 0
      case .joined: return 1
      case .active: return 2
      case .disconnected: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _permission: Livekit_ParticipantPermission? = nil
}

#if swift(>=4.2)

extension Livekit_ParticipantInfo.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_ParticipantInfo.State] = [
    .joining,
    .joined,
    .active,
    .disconnected,
  ]
}

#endif  // swift(>=4.2)

struct Livekit_TrackInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String = String()

  var type: Livekit_TrackType = .audio

  var name: String = String()

  var muted: Bool = false

  /// original width of video (unset for audio)
  /// clients may receive a lower resolution version with simulcast
  var width: UInt32 = 0

  /// original height of video (unset for audio)
  var height: UInt32 = 0

  /// true if track is simulcasted
  var simulcast: Bool = false

  /// true if DTX (Discontinuous Transmission) is disabled for audio
  var disableDtx: Bool = false

  /// source of media
  var source: Livekit_TrackSource = .unknown

  var layers: [Livekit_VideoLayer] = []

  /// mime type of codec
  var mimeType: String = String()

  var mid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// provide information about available spatial layers
struct Livekit_VideoLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for tracks with a single layer, this should be HIGH
  var quality: Livekit_VideoQuality = .low

  var width: UInt32 = 0

  var height: UInt32 = 0

  /// target bitrate, server will measure actual
  var bitrate: UInt32 = 0

  var ssrc: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// new DataPacket API
struct Livekit_DataPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Livekit_DataPacket.Kind = .reliable

  var value: Livekit_DataPacket.OneOf_Value? = nil

  var user: Livekit_UserPacket {
    get {
      if case .user(let v)? = value {return v}
      return Livekit_UserPacket()
    }
    set {value = .user(newValue)}
  }

  var speaker: Livekit_ActiveSpeakerUpdate {
    get {
      if case .speaker(let v)? = value {return v}
      return Livekit_ActiveSpeakerUpdate()
    }
    set {value = .speaker(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case user(Livekit_UserPacket)
    case speaker(Livekit_ActiveSpeakerUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Livekit_DataPacket.OneOf_Value, rhs: Livekit_DataPacket.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.speaker, .speaker): return {
        guard case .speaker(let l) = lhs, case .speaker(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Kind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case reliable // = 0
    case lossy // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .reliable
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reliable
      case 1: self = .lossy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .reliable: return 0
      case .lossy: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Livekit_DataPacket.Kind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_DataPacket.Kind] = [
    .reliable,
    .lossy,
  ]
}

#endif  // swift(>=4.2)

struct Livekit_ActiveSpeakerUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var speakers: [Livekit_SpeakerInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_SpeakerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String = String()

  /// audio level, 0-1.0, 1 is loudest
  var level: Float = 0

  /// true if speaker is currently active
  var active: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_UserPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participant ID of user that sent the message
  var participantSid: String = String()

  /// user defined payload
  var payload: Data = Data()

  /// the ID of the participants who will receive the message (the message will be sent to all the people in the room if this variable is empty)
  var destinationSids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ParticipantTracks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participant ID of participant to whom the tracks belong
  var participantSid: String = String()

  var trackSids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// details about the client
struct Livekit_ClientInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sdk: Livekit_ClientInfo.SDK = .unknown

  var version: String = String()

  var `protocol`: Int32 = 0

  var os: String = String()

  var osVersion: String = String()

  var deviceModel: String = String()

  var browser: String = String()

  var browserVersion: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SDK: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case js // = 1
    case swift // = 2
    case android // = 3
    case flutter // = 4
    case go // = 5
    case unity // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .js
      case 2: self = .swift
      case 3: self = .android
      case 4: self = .flutter
      case 5: self = .go
      case 6: self = .unity
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .js: return 1
      case .swift: return 2
      case .android: return 3
      case .flutter: return 4
      case .go: return 5
      case .unity: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Livekit_ClientInfo.SDK: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Livekit_ClientInfo.SDK] = [
    .unknown,
    .js,
    .swift,
    .android,
    .flutter,
    .go,
    .unity,
  ]
}

#endif  // swift(>=4.2)

/// server provided client configuration
struct Livekit_ClientConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var video: Livekit_VideoConfiguration {
    get {return _video ?? Livekit_VideoConfiguration()}
    set {_video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  var hasVideo: Bool {return self._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  mutating func clearVideo() {self._video = nil}

  var screen: Livekit_VideoConfiguration {
    get {return _screen ?? Livekit_VideoConfiguration()}
    set {_screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  var hasScreen: Bool {return self._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  mutating func clearScreen() {self._screen = nil}

  var resumeConnection: Livekit_ClientConfigSetting = .unset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _video: Livekit_VideoConfiguration? = nil
  fileprivate var _screen: Livekit_VideoConfiguration? = nil
}

struct Livekit_VideoConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hardwareEncoder: Livekit_ClientConfigSetting = .unset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_RTPStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var duration: Double {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  var packets: UInt32 {
    get {return _storage._packets}
    set {_uniqueStorage()._packets = newValue}
  }

  var packetRate: Double {
    get {return _storage._packetRate}
    set {_uniqueStorage()._packetRate = newValue}
  }

  var bytes: UInt64 {
    get {return _storage._bytes}
    set {_uniqueStorage()._bytes = newValue}
  }

  var bitrate: Double {
    get {return _storage._bitrate}
    set {_uniqueStorage()._bitrate = newValue}
  }

  var packetsLost: UInt32 {
    get {return _storage._packetsLost}
    set {_uniqueStorage()._packetsLost = newValue}
  }

  var packetLossRate: Double {
    get {return _storage._packetLossRate}
    set {_uniqueStorage()._packetLossRate = newValue}
  }

  var packetLossPercentage: Float {
    get {return _storage._packetLossPercentage}
    set {_uniqueStorage()._packetLossPercentage = newValue}
  }

  var packetsDuplicate: UInt32 {
    get {return _storage._packetsDuplicate}
    set {_uniqueStorage()._packetsDuplicate = newValue}
  }

  var packetDuplicateRate: Double {
    get {return _storage._packetDuplicateRate}
    set {_uniqueStorage()._packetDuplicateRate = newValue}
  }

  var bytesDuplicate: UInt64 {
    get {return _storage._bytesDuplicate}
    set {_uniqueStorage()._bytesDuplicate = newValue}
  }

  var bitrateDuplicate: Double {
    get {return _storage._bitrateDuplicate}
    set {_uniqueStorage()._bitrateDuplicate = newValue}
  }

  var packetsPadding: UInt32 {
    get {return _storage._packetsPadding}
    set {_uniqueStorage()._packetsPadding = newValue}
  }

  var packetPaddingRate: Double {
    get {return _storage._packetPaddingRate}
    set {_uniqueStorage()._packetPaddingRate = newValue}
  }

  var bytesPadding: UInt64 {
    get {return _storage._bytesPadding}
    set {_uniqueStorage()._bytesPadding = newValue}
  }

  var bitratePadding: Double {
    get {return _storage._bitratePadding}
    set {_uniqueStorage()._bitratePadding = newValue}
  }

  var packetsOutOfOrder: UInt32 {
    get {return _storage._packetsOutOfOrder}
    set {_uniqueStorage()._packetsOutOfOrder = newValue}
  }

  var frames: UInt32 {
    get {return _storage._frames}
    set {_uniqueStorage()._frames = newValue}
  }

  var frameRate: Double {
    get {return _storage._frameRate}
    set {_uniqueStorage()._frameRate = newValue}
  }

  var jitterCurrent: Double {
    get {return _storage._jitterCurrent}
    set {_uniqueStorage()._jitterCurrent = newValue}
  }

  var jitterMax: Double {
    get {return _storage._jitterMax}
    set {_uniqueStorage()._jitterMax = newValue}
  }

  var gapHistogram: Dictionary<Int32,UInt32> {
    get {return _storage._gapHistogram}
    set {_uniqueStorage()._gapHistogram = newValue}
  }

  var nacks: UInt32 {
    get {return _storage._nacks}
    set {_uniqueStorage()._nacks = newValue}
  }

  var nackMisses: UInt32 {
    get {return _storage._nackMisses}
    set {_uniqueStorage()._nackMisses = newValue}
  }

  var plis: UInt32 {
    get {return _storage._plis}
    set {_uniqueStorage()._plis = newValue}
  }

  var lastPli: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastPli ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastPli = newValue}
  }
  /// Returns true if `lastPli` has been explicitly set.
  var hasLastPli: Bool {return _storage._lastPli != nil}
  /// Clears the value of `lastPli`. Subsequent reads from it will return its default value.
  mutating func clearLastPli() {_uniqueStorage()._lastPli = nil}

  var firs: UInt32 {
    get {return _storage._firs}
    set {_uniqueStorage()._firs = newValue}
  }

  var lastFir: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastFir ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastFir = newValue}
  }
  /// Returns true if `lastFir` has been explicitly set.
  var hasLastFir: Bool {return _storage._lastFir != nil}
  /// Clears the value of `lastFir`. Subsequent reads from it will return its default value.
  mutating func clearLastFir() {_uniqueStorage()._lastFir = nil}

  var rttCurrent: UInt32 {
    get {return _storage._rttCurrent}
    set {_uniqueStorage()._rttCurrent = newValue}
  }

  var rttMax: UInt32 {
    get {return _storage._rttMax}
    set {_uniqueStorage()._rttMax = newValue}
  }

  var keyFrames: UInt32 {
    get {return _storage._keyFrames}
    set {_uniqueStorage()._keyFrames = newValue}
  }

  var lastKeyFrame: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastKeyFrame ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastKeyFrame = newValue}
  }
  /// Returns true if `lastKeyFrame` has been explicitly set.
  var hasLastKeyFrame: Bool {return _storage._lastKeyFrame != nil}
  /// Clears the value of `lastKeyFrame`. Subsequent reads from it will return its default value.
  mutating func clearLastKeyFrame() {_uniqueStorage()._lastKeyFrame = nil}

  var layerLockPlis: UInt32 {
    get {return _storage._layerLockPlis}
    set {_uniqueStorage()._layerLockPlis = newValue}
  }

  var lastLayerLockPli: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastLayerLockPli ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastLayerLockPli = newValue}
  }
  /// Returns true if `lastLayerLockPli` has been explicitly set.
  var hasLastLayerLockPli: Bool {return _storage._lastLayerLockPli != nil}
  /// Clears the value of `lastLayerLockPli`. Subsequent reads from it will return its default value.
  mutating func clearLastLayerLockPli() {_uniqueStorage()._lastLayerLockPli = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Livekit_TrackType: @unchecked Sendable {}
extension Livekit_TrackSource: @unchecked Sendable {}
extension Livekit_VideoQuality: @unchecked Sendable {}
extension Livekit_ConnectionQuality: @unchecked Sendable {}
extension Livekit_ClientConfigSetting: @unchecked Sendable {}
extension Livekit_Room: @unchecked Sendable {}
extension Livekit_Codec: @unchecked Sendable {}
extension Livekit_ParticipantPermission: @unchecked Sendable {}
extension Livekit_ParticipantInfo: @unchecked Sendable {}
extension Livekit_ParticipantInfo.State: @unchecked Sendable {}
extension Livekit_TrackInfo: @unchecked Sendable {}
extension Livekit_VideoLayer: @unchecked Sendable {}
extension Livekit_DataPacket: @unchecked Sendable {}
extension Livekit_DataPacket.OneOf_Value: @unchecked Sendable {}
extension Livekit_DataPacket.Kind: @unchecked Sendable {}
extension Livekit_ActiveSpeakerUpdate: @unchecked Sendable {}
extension Livekit_SpeakerInfo: @unchecked Sendable {}
extension Livekit_UserPacket: @unchecked Sendable {}
extension Livekit_ParticipantTracks: @unchecked Sendable {}
extension Livekit_ClientInfo: @unchecked Sendable {}
extension Livekit_ClientInfo.SDK: @unchecked Sendable {}
extension Livekit_ClientConfiguration: @unchecked Sendable {}
extension Livekit_VideoConfiguration: @unchecked Sendable {}
extension Livekit_RTPStats: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "livekit"

extension Livekit_TrackType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO"),
    1: .same(proto: "VIDEO"),
    2: .same(proto: "DATA"),
  ]
}

extension Livekit_TrackSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMERA"),
    2: .same(proto: "MICROPHONE"),
    3: .same(proto: "SCREEN_SHARE"),
    4: .same(proto: "SCREEN_SHARE_AUDIO"),
  ]
}

extension Livekit_VideoQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOW"),
    1: .same(proto: "MEDIUM"),
    2: .same(proto: "HIGH"),
    3: .same(proto: "OFF"),
  ]
}

extension Livekit_ConnectionQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POOR"),
    1: .same(proto: "GOOD"),
    2: .same(proto: "EXCELLENT"),
  ]
}

extension Livekit_ClientConfigSetting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension Livekit_Room: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Room"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "name"),
    3: .standard(proto: "empty_timeout"),
    4: .standard(proto: "max_participants"),
    5: .standard(proto: "creation_time"),
    6: .standard(proto: "turn_password"),
    7: .standard(proto: "enabled_codecs"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "num_participants"),
    10: .standard(proto: "active_recording"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.emptyTimeout) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxParticipants) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.creationTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.turnPassword) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.enabledCodecs) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.numParticipants) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.activeRecording) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sid.isEmpty {
      try visitor.visitSingularStringField(value: self.sid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.emptyTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.emptyTimeout, fieldNumber: 3)
    }
    if self.maxParticipants != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxParticipants, fieldNumber: 4)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.creationTime, fieldNumber: 5)
    }
    if !self.turnPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.turnPassword, fieldNumber: 6)
    }
    if !self.enabledCodecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enabledCodecs, fieldNumber: 7)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 8)
    }
    if self.numParticipants != 0 {
      try visitor.visitSingularUInt32Field(value: self.numParticipants, fieldNumber: 9)
    }
    if self.activeRecording != false {
      try visitor.visitSingularBoolField(value: self.activeRecording, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Room, rhs: Livekit_Room) -> Bool {
    if lhs.sid != rhs.sid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.emptyTimeout != rhs.emptyTimeout {return false}
    if lhs.maxParticipants != rhs.maxParticipants {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.turnPassword != rhs.turnPassword {return false}
    if lhs.enabledCodecs != rhs.enabledCodecs {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.numParticipants != rhs.numParticipants {return false}
    if lhs.activeRecording != rhs.activeRecording {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_Codec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Codec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mime"),
    2: .standard(proto: "fmtp_line"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fmtpLine) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mime.isEmpty {
      try visitor.visitSingularStringField(value: self.mime, fieldNumber: 1)
    }
    if !self.fmtpLine.isEmpty {
      try visitor.visitSingularStringField(value: self.fmtpLine, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Codec, rhs: Livekit_Codec) -> Bool {
    if lhs.mime != rhs.mime {return false}
    if lhs.fmtpLine != rhs.fmtpLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_subscribe"),
    2: .standard(proto: "can_publish"),
    3: .standard(proto: "can_publish_data"),
    7: .same(proto: "hidden"),
    8: .same(proto: "recorder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canSubscribe) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canPublish) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canPublishData) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hidden) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.recorder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canSubscribe != false {
      try visitor.visitSingularBoolField(value: self.canSubscribe, fieldNumber: 1)
    }
    if self.canPublish != false {
      try visitor.visitSingularBoolField(value: self.canPublish, fieldNumber: 2)
    }
    if self.canPublishData != false {
      try visitor.visitSingularBoolField(value: self.canPublishData, fieldNumber: 3)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 7)
    }
    if self.recorder != false {
      try visitor.visitSingularBoolField(value: self.recorder, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ParticipantPermission, rhs: Livekit_ParticipantPermission) -> Bool {
    if lhs.canSubscribe != rhs.canSubscribe {return false}
    if lhs.canPublish != rhs.canPublish {return false}
    if lhs.canPublishData != rhs.canPublishData {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.recorder != rhs.recorder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "identity"),
    3: .same(proto: "state"),
    4: .same(proto: "tracks"),
    5: .same(proto: "metadata"),
    6: .standard(proto: "joined_at"),
    9: .same(proto: "name"),
    10: .same(proto: "version"),
    11: .same(proto: "permission"),
    12: .same(proto: "region"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.joinedAt) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._permission) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.region) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sid.isEmpty {
      try visitor.visitSingularStringField(value: self.sid, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if self.state != .joining {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 5)
    }
    if self.joinedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.joinedAt, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 9)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 10)
    }
    try { if let v = self._permission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ParticipantInfo, rhs: Livekit_ParticipantInfo) -> Bool {
    if lhs.sid != rhs.sid {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.state != rhs.state {return false}
    if lhs.tracks != rhs.tracks {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.joinedAt != rhs.joinedAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs._permission != rhs._permission {return false}
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantInfo.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JOINING"),
    1: .same(proto: "JOINED"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "DISCONNECTED"),
  ]
}

extension Livekit_TrackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "muted"),
    5: .same(proto: "width"),
    6: .same(proto: "height"),
    7: .same(proto: "simulcast"),
    8: .standard(proto: "disable_dtx"),
    9: .same(proto: "source"),
    10: .same(proto: "layers"),
    11: .standard(proto: "mime_type"),
    12: .same(proto: "mid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.muted) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.simulcast) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.disableDtx) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sid.isEmpty {
      try visitor.visitSingularStringField(value: self.sid, fieldNumber: 1)
    }
    if self.type != .audio {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.muted != false {
      try visitor.visitSingularBoolField(value: self.muted, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 6)
    }
    if self.simulcast != false {
      try visitor.visitSingularBoolField(value: self.simulcast, fieldNumber: 7)
    }
    if self.disableDtx != false {
      try visitor.visitSingularBoolField(value: self.disableDtx, fieldNumber: 8)
    }
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 9)
    }
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 10)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 11)
    }
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_TrackInfo, rhs: Livekit_TrackInfo) -> Bool {
    if lhs.sid != rhs.sid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.muted != rhs.muted {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.simulcast != rhs.simulcast {return false}
    if lhs.disableDtx != rhs.disableDtx {return false}
    if lhs.source != rhs.source {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.mid != rhs.mid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_VideoLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quality"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .same(proto: "bitrate"),
    5: .same(proto: "ssrc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.quality) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.bitrate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ssrc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quality != .low {
      try visitor.visitSingularEnumField(value: self.quality, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 3)
    }
    if self.bitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.bitrate, fieldNumber: 4)
    }
    if self.ssrc != 0 {
      try visitor.visitSingularUInt32Field(value: self.ssrc, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_VideoLayer, rhs: Livekit_VideoLayer) -> Bool {
    if lhs.quality != rhs.quality {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.ssrc != rhs.ssrc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "user"),
    3: .same(proto: "speaker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try {
        var v: Livekit_UserPacket?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .user(v)
        }
      }()
      case 3: try {
        var v: Livekit_ActiveSpeakerUpdate?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .speaker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .speaker(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .reliable {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    switch self.value {
    case .user?: try {
      guard case .user(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .speaker?: try {
      guard case .speaker(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataPacket, rhs: Livekit_DataPacket) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataPacket.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RELIABLE"),
    1: .same(proto: "LOSSY"),
  ]
}

extension Livekit_ActiveSpeakerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveSpeakerUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "speakers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.speakers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.speakers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.speakers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ActiveSpeakerUpdate, rhs: Livekit_ActiveSpeakerUpdate) -> Bool {
    if lhs.speakers != rhs.speakers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_SpeakerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeakerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "level"),
    3: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sid) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.level) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sid.isEmpty {
      try visitor.visitSingularStringField(value: self.sid, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularFloatField(value: self.level, fieldNumber: 2)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_SpeakerInfo, rhs: Livekit_SpeakerInfo) -> Bool {
    if lhs.sid != rhs.sid {return false}
    if lhs.level != rhs.level {return false}
    if lhs.active != rhs.active {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_UserPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_sid"),
    2: .same(proto: "payload"),
    3: .standard(proto: "destination_sids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.participantSid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.destinationSids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participantSid.isEmpty {
      try visitor.visitSingularStringField(value: self.participantSid, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.destinationSids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destinationSids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_UserPacket, rhs: Livekit_UserPacket) -> Bool {
    if lhs.participantSid != rhs.participantSid {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.destinationSids != rhs.destinationSids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantTracks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantTracks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_sid"),
    2: .standard(proto: "track_sids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.participantSid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.trackSids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participantSid.isEmpty {
      try visitor.visitSingularStringField(value: self.participantSid, fieldNumber: 1)
    }
    if !self.trackSids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.trackSids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ParticipantTracks, rhs: Livekit_ParticipantTracks) -> Bool {
    if lhs.participantSid != rhs.participantSid {return false}
    if lhs.trackSids != rhs.trackSids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdk"),
    2: .same(proto: "version"),
    3: .same(proto: "protocol"),
    4: .same(proto: "os"),
    5: .standard(proto: "os_version"),
    6: .standard(proto: "device_model"),
    7: .same(proto: "browser"),
    8: .standard(proto: "browser_version"),
    9: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sdk) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.`protocol`) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.browser) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.browserVersion) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sdk != .unknown {
      try visitor.visitSingularEnumField(value: self.sdk, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.`protocol` != 0 {
      try visitor.visitSingularInt32Field(value: self.`protocol`, fieldNumber: 3)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 6)
    }
    if !self.browser.isEmpty {
      try visitor.visitSingularStringField(value: self.browser, fieldNumber: 7)
    }
    if !self.browserVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.browserVersion, fieldNumber: 8)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ClientInfo, rhs: Livekit_ClientInfo) -> Bool {
    if lhs.sdk != rhs.sdk {return false}
    if lhs.version != rhs.version {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.os != rhs.os {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.browser != rhs.browser {return false}
    if lhs.browserVersion != rhs.browserVersion {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ClientInfo.SDK: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "JS"),
    2: .same(proto: "SWIFT"),
    3: .same(proto: "ANDROID"),
    4: .same(proto: "FLUTTER"),
    5: .same(proto: "GO"),
    6: .same(proto: "UNITY"),
  ]
}

extension Livekit_ClientConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "video"),
    2: .same(proto: "screen"),
    3: .standard(proto: "resume_connection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._video) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.resumeConnection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.resumeConnection != .unset {
      try visitor.visitSingularEnumField(value: self.resumeConnection, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ClientConfiguration, rhs: Livekit_ClientConfiguration) -> Bool {
    if lhs._video != rhs._video {return false}
    if lhs._screen != rhs._screen {return false}
    if lhs.resumeConnection != rhs.resumeConnection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_VideoConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hardware_encoder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hardwareEncoder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hardwareEncoder != .unset {
      try visitor.visitSingularEnumField(value: self.hardwareEncoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_VideoConfiguration, rhs: Livekit_VideoConfiguration) -> Bool {
    if lhs.hardwareEncoder != rhs.hardwareEncoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RTPStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTPStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "duration"),
    4: .same(proto: "packets"),
    5: .standard(proto: "packet_rate"),
    6: .same(proto: "bytes"),
    7: .same(proto: "bitrate"),
    8: .standard(proto: "packets_lost"),
    9: .standard(proto: "packet_loss_rate"),
    10: .standard(proto: "packet_loss_percentage"),
    11: .standard(proto: "packets_duplicate"),
    12: .standard(proto: "packet_duplicate_rate"),
    13: .standard(proto: "bytes_duplicate"),
    14: .standard(proto: "bitrate_duplicate"),
    15: .standard(proto: "packets_padding"),
    16: .standard(proto: "packet_padding_rate"),
    17: .standard(proto: "bytes_padding"),
    18: .standard(proto: "bitrate_padding"),
    19: .standard(proto: "packets_out_of_order"),
    20: .same(proto: "frames"),
    21: .standard(proto: "frame_rate"),
    22: .standard(proto: "jitter_current"),
    23: .standard(proto: "jitter_max"),
    24: .standard(proto: "gap_histogram"),
    25: .same(proto: "nacks"),
    26: .standard(proto: "nack_misses"),
    27: .same(proto: "plis"),
    28: .standard(proto: "last_pli"),
    29: .same(proto: "firs"),
    30: .standard(proto: "last_fir"),
    31: .standard(proto: "rtt_current"),
    32: .standard(proto: "rtt_max"),
    33: .standard(proto: "key_frames"),
    34: .standard(proto: "last_key_frame"),
    35: .standard(proto: "layer_lock_plis"),
    36: .standard(proto: "last_layer_lock_pli"),
  ]

  fileprivate class _StorageClass {
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _duration: Double = 0
    var _packets: UInt32 = 0
    var _packetRate: Double = 0
    var _bytes: UInt64 = 0
    var _bitrate: Double = 0
    var _packetsLost: UInt32 = 0
    var _packetLossRate: Double = 0
    var _packetLossPercentage: Float = 0
    var _packetsDuplicate: UInt32 = 0
    var _packetDuplicateRate: Double = 0
    var _bytesDuplicate: UInt64 = 0
    var _bitrateDuplicate: Double = 0
    var _packetsPadding: UInt32 = 0
    var _packetPaddingRate: Double = 0
    var _bytesPadding: UInt64 = 0
    var _bitratePadding: Double = 0
    var _packetsOutOfOrder: UInt32 = 0
    var _frames: UInt32 = 0
    var _frameRate: Double = 0
    var _jitterCurrent: Double = 0
    var _jitterMax: Double = 0
    var _gapHistogram: Dictionary<Int32,UInt32> = [:]
    var _nacks: UInt32 = 0
    var _nackMisses: UInt32 = 0
    var _plis: UInt32 = 0
    var _lastPli: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _firs: UInt32 = 0
    var _lastFir: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rttCurrent: UInt32 = 0
    var _rttMax: UInt32 = 0
    var _keyFrames: UInt32 = 0
    var _lastKeyFrame: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _layerLockPlis: UInt32 = 0
    var _lastLayerLockPli: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startTime = source._startTime
      _endTime = source._endTime
      _duration = source._duration
      _packets = source._packets
      _packetRate = source._packetRate
      _bytes = source._bytes
      _bitrate = source._bitrate
      _packetsLost = source._packetsLost
      _packetLossRate = source._packetLossRate
      _packetLossPercentage = source._packetLossPercentage
      _packetsDuplicate = source._packetsDuplicate
      _packetDuplicateRate = source._packetDuplicateRate
      _bytesDuplicate = source._bytesDuplicate
      _bitrateDuplicate = source._bitrateDuplicate
      _packetsPadding = source._packetsPadding
      _packetPaddingRate = source._packetPaddingRate
      _bytesPadding = source._bytesPadding
      _bitratePadding = source._bitratePadding
      _packetsOutOfOrder = source._packetsOutOfOrder
      _frames = source._frames
      _frameRate = source._frameRate
      _jitterCurrent = source._jitterCurrent
      _jitterMax = source._jitterMax
      _gapHistogram = source._gapHistogram
      _nacks = source._nacks
      _nackMisses = source._nackMisses
      _plis = source._plis
      _lastPli = source._lastPli
      _firs = source._firs
      _lastFir = source._lastFir
      _rttCurrent = source._rttCurrent
      _rttMax = source._rttMax
      _keyFrames = source._keyFrames
      _lastKeyFrame = source._lastKeyFrame
      _layerLockPlis = source._layerLockPlis
      _lastLayerLockPli = source._lastLayerLockPli
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._duration) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._packets) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._packetRate) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytes) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._bitrate) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsLost) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._packetLossRate) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._packetLossPercentage) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsDuplicate) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._packetDuplicateRate) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesDuplicate) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._bitrateDuplicate) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsPadding) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._packetPaddingRate) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesPadding) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._bitratePadding) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsOutOfOrder) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._frames) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._frameRate) }()
        case 22: try { try decoder.decodeSingularDoubleField(value: &_storage._jitterCurrent) }()
        case 23: try { try decoder.decodeSingularDoubleField(value: &_storage._jitterMax) }()
        case 24: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufUInt32>.self, value: &_storage._gapHistogram) }()
        case 25: try { try decoder.decodeSingularUInt32Field(value: &_storage._nacks) }()
        case 26: try { try decoder.decodeSingularUInt32Field(value: &_storage._nackMisses) }()
        case 27: try { try decoder.decodeSingularUInt32Field(value: &_storage._plis) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._lastPli) }()
        case 29: try { try decoder.decodeSingularUInt32Field(value: &_storage._firs) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._lastFir) }()
        case 31: try { try decoder.decodeSingularUInt32Field(value: &_storage._rttCurrent) }()
        case 32: try { try decoder.decodeSingularUInt32Field(value: &_storage._rttMax) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._keyFrames) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._lastKeyFrame) }()
        case 35: try { try decoder.decodeSingularUInt32Field(value: &_storage._layerLockPlis) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._lastLayerLockPli) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._duration != 0 {
        try visitor.visitSingularDoubleField(value: _storage._duration, fieldNumber: 3)
      }
      if _storage._packets != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packets, fieldNumber: 4)
      }
      if _storage._packetRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetRate, fieldNumber: 5)
      }
      if _storage._bytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytes, fieldNumber: 6)
      }
      if _storage._bitrate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._bitrate, fieldNumber: 7)
      }
      if _storage._packetsLost != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsLost, fieldNumber: 8)
      }
      if _storage._packetLossRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetLossRate, fieldNumber: 9)
      }
      if _storage._packetLossPercentage != 0 {
        try visitor.visitSingularFloatField(value: _storage._packetLossPercentage, fieldNumber: 10)
      }
      if _storage._packetsDuplicate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsDuplicate, fieldNumber: 11)
      }
      if _storage._packetDuplicateRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetDuplicateRate, fieldNumber: 12)
      }
      if _storage._bytesDuplicate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytesDuplicate, fieldNumber: 13)
      }
      if _storage._bitrateDuplicate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._bitrateDuplicate, fieldNumber: 14)
      }
      if _storage._packetsPadding != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsPadding, fieldNumber: 15)
      }
      if _storage._packetPaddingRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetPaddingRate, fieldNumber: 16)
      }
      if _storage._bytesPadding != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytesPadding, fieldNumber: 17)
      }
      if _storage._bitratePadding != 0 {
        try visitor.visitSingularDoubleField(value: _storage._bitratePadding, fieldNumber: 18)
      }
      if _storage._packetsOutOfOrder != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsOutOfOrder, fieldNumber: 19)
      }
      if _storage._frames != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._frames, fieldNumber: 20)
      }
      if _storage._frameRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._frameRate, fieldNumber: 21)
      }
      if _storage._jitterCurrent != 0 {
        try visitor.visitSingularDoubleField(value: _storage._jitterCurrent, fieldNumber: 22)
      }
      if _storage._jitterMax != 0 {
        try visitor.visitSingularDoubleField(value: _storage._jitterMax, fieldNumber: 23)
      }
      if !_storage._gapHistogram.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufUInt32>.self, value: _storage._gapHistogram, fieldNumber: 24)
      }
      if _storage._nacks != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nacks, fieldNumber: 25)
      }
      if _storage._nackMisses != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nackMisses, fieldNumber: 26)
      }
      if _storage._plis != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._plis, fieldNumber: 27)
      }
      try { if let v = _storage._lastPli {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      if _storage._firs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._firs, fieldNumber: 29)
      }
      try { if let v = _storage._lastFir {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      if _storage._rttCurrent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rttCurrent, fieldNumber: 31)
      }
      if _storage._rttMax != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rttMax, fieldNumber: 32)
      }
      if _storage._keyFrames != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._keyFrames, fieldNumber: 33)
      }
      try { if let v = _storage._lastKeyFrame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      if _storage._layerLockPlis != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._layerLockPlis, fieldNumber: 35)
      }
      try { if let v = _storage._lastLayerLockPli {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RTPStats, rhs: Livekit_RTPStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._packets != rhs_storage._packets {return false}
        if _storage._packetRate != rhs_storage._packetRate {return false}
        if _storage._bytes != rhs_storage._bytes {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._packetsLost != rhs_storage._packetsLost {return false}
        if _storage._packetLossRate != rhs_storage._packetLossRate {return false}
        if _storage._packetLossPercentage != rhs_storage._packetLossPercentage {return false}
        if _storage._packetsDuplicate != rhs_storage._packetsDuplicate {return false}
        if _storage._packetDuplicateRate != rhs_storage._packetDuplicateRate {return false}
        if _storage._bytesDuplicate != rhs_storage._bytesDuplicate {return false}
        if _storage._bitrateDuplicate != rhs_storage._bitrateDuplicate {return false}
        if _storage._packetsPadding != rhs_storage._packetsPadding {return false}
        if _storage._packetPaddingRate != rhs_storage._packetPaddingRate {return false}
        if _storage._bytesPadding != rhs_storage._bytesPadding {return false}
        if _storage._bitratePadding != rhs_storage._bitratePadding {return false}
        if _storage._packetsOutOfOrder != rhs_storage._packetsOutOfOrder {return false}
        if _storage._frames != rhs_storage._frames {return false}
        if _storage._frameRate != rhs_storage._frameRate {return false}
        if _storage._jitterCurrent != rhs_storage._jitterCurrent {return false}
        if _storage._jitterMax != rhs_storage._jitterMax {return false}
        if _storage._gapHistogram != rhs_storage._gapHistogram {return false}
        if _storage._nacks != rhs_storage._nacks {return false}
        if _storage._nackMisses != rhs_storage._nackMisses {return false}
        if _storage._plis != rhs_storage._plis {return false}
        if _storage._lastPli != rhs_storage._lastPli {return false}
        if _storage._firs != rhs_storage._firs {return false}
        if _storage._lastFir != rhs_storage._lastFir {return false}
        if _storage._rttCurrent != rhs_storage._rttCurrent {return false}
        if _storage._rttMax != rhs_storage._rttMax {return false}
        if _storage._keyFrames != rhs_storage._keyFrames {return false}
        if _storage._lastKeyFrame != rhs_storage._lastKeyFrame {return false}
        if _storage._layerLockPlis != rhs_storage._layerLockPlis {return false}
        if _storage._lastLayerLockPli != rhs_storage._lastLayerLockPli {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
